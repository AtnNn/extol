%% Debugging

% Trace
pred t: (X: write('trace: '), ti, writeq(X), nl).

dcg t: (X:
        {write('trace: '), ti, writeq(X), write(', at: ')},
        peek(A), {pretty_init(A, C), write(C),
        nl}, !).

pred pretty_init: (A, C :
    copy_term(A, AA),
    (length(B, 32), append(B, _, AA) ; B = AA), !,
    prep_chars(B, Q, []),
    length(Q, N),
    (N < 10 -> append(Q, "<eof>", QQ) ; QQ = Q),
    atom_codes(C, QQ)).

dcg prep_chars:
([]: []),
([X | Xs]: prep_char(X), prep_chars(Xs)).

dcg prep_char:
(X: { var(X) }, !, "<?>"),
(0'\n: !, "<nl>"),
(0'\r: !, "<cr>"),
(0'\t: !, "<tab>"),
(0'<: !, "<lt>"),
(X:
 { ( \+integer(X) ; X < 32 ; X > 126), !,
   open_output_codes_stream(S),
   write(S, X),
   close_output_codes_stream(S, C) },
 "<", C, ">", !),
(X: [X]).

% Trace and fail
pred tf: (X: t(X), fail).

pred tf: (X, A, B: tf(X, A, B), fail).

% Trace call
pred tc: (F:
          undo(t(failed(F))),
          t(enter(F)),
          ticall(F),
          undo(t(redo(F))),
          t(exit(F))).

dcg tc: ((F):
    undo(t(failed(F))),
    t(enter(F)),
    ticall(F),
    undo(t(redo(F))),
    t(exit(F))).

dcg tc: ((F, X):
    undo(t(failed(F))),
    t(enter(F)),
    ticall(F, X),
    undo(t(redo(F))),
    t(exit(F))).

% Trace indent

pred ti: (():
    Pat = [0'|, 0' , 0'., 0' , 0'., 0'  | Pat],
    g_read(tindent, I),
    II is I * 2,
    length(L, II),
    append(L, _, Pat),
    atom_codes(S, L),
    write(S)).

prolog ticall(G) :-
    g_read(tindent, I),
    II is I + 1,
    g_assignb(tindent, II),
    call(G),
    g_assignb(tindent, I).

prolog ticall(G, A, B) :-
    g_read(tindent, I),
    II is I + 1,
    g_assignb(tindent, II),
    dcg_call(G, A, B),
    g_assignb(tindent, I).

prolog ticall(G, X, A, B) :-
    g_read(tindent, I),
    II is I + 1,
    g_assignb(tindent, II),
    G =.. L,
    append(L, [X], LL),
    GX =.. LL,
    dcg_call(GX, A, B),
    g_assignb(tindent, I).

% Call on undo

prolog undo(_) :- true.
prolog undo(G) :- call(G), fail.

prolog undo(_, A, A) :- true.
prolog undo(G, A, B) :- dcg_call(G, A, B), fail.

%% Types

prolog byte(Byte) :- number(Byte), Byte >= 0, Byte < 256.

prolog bytes(Bytes) :- ground(Bytes), maplist(byte, Bytes).

prolog assert((A, B)) :- assert(A), assert(B).
prolog assert(G) :- G, !.
prolog assert(G) :- throw(assert_failed(G)).

%% Streams

pred read_bytes:
contract((Stream, Bytes), ground(Stream), bytes(Bytes)),
((Stream, []): at_end_of_stream(Stream), !),
((Stream, [X | Xs]):
 get_byte(Stream, X),
 '__contract_free_read_bytes'(Stream, Xs)).

pred write_bytes:
contract((Stream, Bytes), (ground(Stream), current_stream(Stream), bytes(Bytes)), true),
((_, []) : true),
((Stream, [X | Xs]) :
    put_byte(Stream, X),
    '__contract_free_write_bytes'(Stream, Xs)).

pred read_file:
contract((Path, Bytes), atom(Path), bytes(Bytes)),
((Path, Bytes) :
    open(Path, read, Stream, [type(binary), buffering(block)]),
    read_bytes(Stream, Bytes),
    close(Stream)).

pred write_file:
contract((Path, Bytes), (ground(Path), bytes(Bytes)), true),
((Path, Bytes) :
    open(Path, write, Stream, [type(binary), buffering(block)]),
    write_bytes(Stream, Bytes),
    close(Stream)).

pred read_line:
(([]): current_input(Stream), at_end_of_stream(Stream), !),
(([X | Xs]):
 current_input(Stream),
 line_count(Stream, Line),
 get_char(C),
 atom_codes(C, [X]),
 ( line_count(Stream, Line), read_line(Xs)
 ; Xs = [])).

%% Main

prolog main :-
    catch((
                 current_prolog_flag(argv, [_, Command | Args]),
                 command(Command, Args),
                 halt
             ), Exception, (
              write('failed: '),
              write(Exception), nl,
              halt(1)
          )).

prolog command(test, Args) :-
    ( write('Running tests'), nl,
      test((Name :- Goals)),
      ([Name] = Args ; Args = []),
      write(Name), write('...'),
      once(run_test(Goals)),
      fail)
    ; true.

prolog command(extoltoprolog, [In, Out]) :-
    t('reading input file...'),
    read_file(In, BytesIn), !,
    t('parsing contents...'),
    xtl_top_level(DeclsXTL, BytesIn, []), !,
    t('converting to prolog...'),
    xtl_to_pl_toplevel(DeclsXTL, DeclsPL),
    t('writing output file...'),
    pl_write_top_level(DeclsPL, BytesGen, []), !,
    append("% Generated by extoltoprolog\n", BytesGen, BytesOut),
    write_file(Out, BytesOut).

pred command: ((repl, []): xtl_repl).

pred command: ((Command, _): write(unknown_command(Command)), false).

prolog run_test(done) :- !, write(success), nl.
prolog run_test((A, B)) :- !,
    (call(A)
     -> run_test(B)
     ; nl, write('  failed: '), write(A), nl, throw(test_failed)).
prolog run_test(B) :-
    run_test((B, done)).

test 'test_c' :-
    read_file('test.c', Bytes), !,
    c_pp([], Tokens, Bytes, []), !,
    c_top_level(_Decls, Tokens, []).

%% Parsing

dcg many:
% TODO ATN contract((Predicate, List), (callable(Predicate), list_or_partial_list(List)), list(List)),
%((P, [X | Xs]): call(P, X), '__contract_free_many'(P, Xs), !),
((P, [X | Xs]): call(P, X), many(P, Xs), !),
((_, []): []).

dcg many1:
contract((Predicate, List), (callable(Predicate), list_or_partial_list(List)), list(List)),
((P, [X | Xs]): call(P, X), !, many(P, Xs)).

pred eof:
contract((In, Out), (list_or_partial_list(In), list_or_partial_list(Out)), true),
(([], []): true).

pred peek:
contract((Rest, In, Out), (list_or_partial_list(In), list_or_partial_list(Out), list_or_partial_list(Rest)), true),
((Rest, Rest, Rest) : true).

dcg alpha:
contract((C), true, number(C)),
((C): [C], { member(C, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") }).

dcg digit:
contract((D), true, number(D)),
((D):
    [C],
    { member(C - D, [0'0 - 0, 0'1 - 1, 0'2 - 2, 0'3 - 3, 0'4 - 4, 0'5 - 5, 0'6 - 6, 0'7 - 7, 0'8 - 8, 0'9 - 9]) }).

prolog dcg_call(Var) --> { var(Var), !, fail }.
prolog dcg_call([]) --> !, [].
prolog dcg_call([X | Xs]) --> !, [X], Xs.
prolog dcg_call((A, B)) --> !, A, B.
prolog dcg_call((A ; _)) --> A.
prolog dcg_call((_ ; B)) --> !, B.
prolog dcg_call({A}) --> !, { A }.
prolog dcg_call(G, I, O) :- !, call(G, I, O).

prolog require(N, Xs, Rest) :-
    ( dcg_call(N, Xs, Rest), !
    ; pretty_init(Xs, C), throw(parse_failed(N, C)) ).

pred must:
((G): undo(throw(failed(G))), G).
pred must:
((G, A): undo(throw(failed(call(G, A)))), call(G, A)).
pred must:
((G, A, B): undo(throw(failed(call(G, A, B)))), call(G, A, B)).
pred must:
((G, A, B, C): undo(throw(failed(call(G, A, B, C)))), call(G, A, B, C)).

prolog try(N, Xs, Rest) :- catch(dcg_call(N, Xs, Rest), parse_failed(_, _), Failed=true), !, Failed=false.

%% Lists

pred foldl:
contract((F, Z, L, RR), (callable(F), list_or_partial_list(L)), list(L)),
((_, R, [], R): true),
((F, Z, [X | Xs], RR): call(F, Z, X, R), '__contract_free_foldl'(F, R, Xs, RR)).

prolog append([], []) :- true.
prolog append([X | Xs], L) :-
    append(Xs, LL),
    append(X, LL, L).

prolog comma_list(Var, [Var]) :- var(Var), !.
prolog comma_list((X, XCs), [X | Xs]) :- !, comma_list(XCs, Xs), !.
prolog comma_list('()', []) :- !.
prolog comma_list(X, [X]) :- !.

test comma_list :-
    comma_list('()', []),
    comma_list((1), [1]),
    comma_list((1,2), [1,2]),
    comma_list((1,2,3), [1,2,3]),
    comma_list(X, [X]),
    comma_list((1,2,X), [1,2,X]).

%% C preprocessor

prolog c_pp(Env, Tokens) -->
    c_pp_lines(Lines), eof, !,
    { c_pp_eval(Env, Lines, Tokens, []) }.

prolog c_pp_lines([]) --> eof, !.
prolog c_pp_lines([Line | Lines]) --> c_pp_line(Line), !, c_pp_lines(Lines).

prolog c_pp_line([]) --> c_pp_skipwhite, ("\n", ! ; eof), !.
prolog c_pp_line([Token | Tokens]) --> c_pp_skipwhite, !, c_pp_token(Token), !, c_pp_line(Tokens).

prolog c_pp_skipwhite --> c_pp_white, !.
prolog c_pp_skipwhite --> [].

prolog c_pp_white --> "//", !, c_pp_line_comment_.
prolog c_pp_white --> "/*", !, c_pp_block_comment_, c_pp_skipwhite.
prolog c_pp_white --> (" "; "\t"; "\r" ; "\\\r\n" ; "\\\n"), !, c_pp_skipwhite.

prolog c_pp_line_comment_ --> (peek([0'\n | _]) ; eof), !.
prolog c_pp_line_comment_ --> c_pp_white, !, c_pp_line_comment_.
prolog c_pp_line_comment_ --> [_], !, c_pp_line_comment_.

prolog c_pp_block_comment_ --> "*/", !.
prolog c_pp_block_comment_ --> [_], c_pp_block_comment_.

prolog c_pp_token(Token) --> (c_pp_operator(Token) ; c_pp_symbol(Token) ; c_pp_integer(Token)), !.

prolog c_pp_operator(operator(Token), Next, Rest) :-
    member(Op, [
               "=",
               "#", ";"
    ]),
    append(Op, Rest, Next),
    atom_codes(Token, Op).

prolog c_pp_symbol(symbol(Name)) --> c_pp_symbol_chars(Cs), { atom_codes(Name, Cs) }.

prolog c_pp_symbol_chars([X | Xs]) --> c_pp_symbol_first(X), !, many(c_pp_symbol_char, Xs).

prolog c_pp_symbol_first(C) --> alpha(C), !.
prolog c_pp_symbol_first(0'_) --> "_".

prolog c_pp_symbol_char(C) --> c_pp_symbol_first(C); [C], { member(C, "0123456789") }.

prolog add_digit(N, D, R) :-
    member(D, [0,1,2,3,4,5,6,7,8,9]),
    ( var(N), N is R div D; true),
    R is N * 10 + D.

prolog c_pp_integer(integer(N)) -->
    many1(digit, Ds), !,
    { foldl(add_digit, 0, Ds, N) }.

prolog c_pp_eval(_, []) --> eof, !.
prolog c_pp_eval(EnvA, [Line | Lines]) -->
    c_pp_eval_line(EnvA, EnvB, Line), !,
    c_pp_eval(EnvB, Lines).

prolog c_pp_eval_line(Env, [Name = Value | Env], [operator('#'), symbol('define'), symbol(Name) | Value]) --> !.
prolog c_pp_eval_line(Env, Env, []) --> !.
prolog c_pp_eval_line(Env, Env, [symbol(X) | Xs]) -->
    { member(X = Ys, Env), !, append(Ys, Xs, Zs) },
    c_pp_eval_line(Env, Env, Zs).
prolog c_pp_eval_line(Env, Env, [X | Xs]) -->
    [X],
    c_pp_eval_line(Env, Env, Xs).

%% C

prolog c_top_level(Decls) --> many(c_declaration, Decls), eof.

prolog c_declaration(declare(Name, Type, Value)) -->
    c_type(Type),
    [symbol(Name)],
    ( [operator('=')],
      c_value(Assign), !,
      { Value = value(Assign) }
    ; { Value = none } ),
    [operator(';')].

prolog c_type(Type) --> [symbol(Type)].

prolog c_value(variable(Name)) --> [symbol(Name)].
prolog c_value(integer(N)) --> [integer(N)].

%% Prolog

prolog pl_token(N) --> N, pl_skipwhite, !.

test pl_token :-
    pl_token("x", "x  ", ""),
    pl_token("x", "x % comment", ""),
    pl_token("x", "x % comment\n  \t", "").

prolog pl_skipwhite --> pl_white, !.
prolog pl_skipwhite --> [].

test pl_skipwhite :-
    pl_skipwhite("", "").

prolog pl_white --> "%", !, pl_line_comment_, pl_skipwhite.
prolog pl_white --> (" "; "\t"; "\r" ; "\n" ), !, pl_skipwhite.

test pl_white :-
    pl_white(" ", ""),
    pl_white("%", ""),
    pl_white("% comment \n\t  ", "").

prolog pl_line_comment_ --> ("\n" ; eof), !.
prolog pl_line_comment_ --> [_], pl_line_comment_.

prolog pl_top_level(Decls) -->
    ( "#!", !, pl_line_comment_; { true }),
    pl_skipwhite,
    many(pl_declaration, Decls),
    require(eof).

prolog pl_write_top_level([]) --> [].
prolog pl_write_top_level([Decl | Decls]) -->
    pl_write_term(Decl), ".\n",
    pl_write_top_level(Decls).

prolog pl_write_term(X) -->
    { open_output_codes_stream(Stream),
      write_term(Stream, X, [quoted(true), namevars(true), numbervars(true), ignore_ops(true)]),
      close_output_codes_stream(Stream, Bytes) },
    Bytes.

prolog pl_declaration(_) --> eof, !, {fail}.
prolog pl_declaration(Decl) --> pl_expression(Decl), require(pl_token(".")).

prolog pl_atom_char(C) -->
    [C], !,
    { member(C, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789") }.

prolog pl_atom(Atom) -->
    "'",
    pl_quoted_atom_chars_(Cs),
    { atom_codes(Atom, Cs) }.
prolog pl_atom(AtomVar) -->
    many1(pl_atom_char, Cs), !,
    { atom_codes(Atom, Cs),
      ( Cs = [C|_],
        member(C, "_ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
        !, AtomVar =.. ['$VARNAME', Atom]
      ; AtomVar = Atom )}.

test pl_atom :-
    pl_atom(a, "'a'", ""),
    pl_atom('+', "'+'", ""),
    pl_atom('9', "'\\9'", ""),
    pl_atom(ab, "ab", ""),
    pl_atom(ab, "ab", "").

prolog pl_quoted_char(C) -->
    "\\", !,
    require([Quoted]),
    { member(Quoted - C, [
                 0'n - 10,
                 0'r - 13,
                 0't - 9,
                 0'e - 127,
                 AsIs - AsIs
    ]) }, !.

prolog pl_quoted_atom_chars_([]) --> "'", !.
prolog pl_quoted_atom_chars_([C | Cs]) -->
    pl_quoted_char(C), !,
    pl_quoted_atom_chars_(Cs).
prolog pl_quoted_atom_chars_([C | Cs]) -->
    [C],
    pl_quoted_atom_chars_(Cs).

prolog pl_expression(Expr) -->
    pl_expression(1201, Expr).

prolog pl_expression(Prec, Expr) -->
    pl_expression(none, Prec, Expr).

test pl_expression :-
    pl_expression(1, "1", []),
    pl_expression(a, "a", []),
    pl_expression(a + b, "a + b", []),
    pl_expression(a + (b * c), "a + b * c", []),
    pl_expression((a * b) + c, "a * b + c", []),
    pl_expression((-a) * b, "-a * b", []),
    pl_expression((:- (a * b)), ":- a * b", []).

test pl_comma_expr :-
    pl_expression((p :- (a, b)), "p :- a, b", []).

prolog pl_regular_term(Char) --> "0'", !, require(pl_string_char(Char)), pl_skipwhite.
prolog pl_regular_term(Integer) -->
    many1(digit, Ds), !,
    { foldl(add_digit, 0, Ds, Integer) },
    pl_skipwhite.
prolog pl_regular_term(String) --> "\"", !, require(many(pl_string_char, String)), require("\""), pl_skipwhite.
prolog pl_regular_term(Term) -->
    pl_atom(Atom), !,
    ( pl_token("("), !,
      pl_comma_separated(Args, [], pl_token(")")),
      { Term =.. [Atom | Args] }
    ; pl_skipwhite,
      { Term = Atom }).
prolog pl_regular_term(Term) -->
    pl_token("("),
    pl_expression(Term),
    require(pl_token(")")).
prolog pl_regular_term('{}'(Term)) -->
    pl_token("{"),
    pl_expression(Term),
    require(pl_token("}")).
prolog pl_regular_term(Term) -->
    pl_token("["),
    pl_comma_separated(Term, Tail,
                       ( pl_token("]"), {Tail=[]}
                       ; pl_token("|"), pl_expression(Tail), pl_token("]"))), !.

prolog pl_string_char(_) --> "\"", !, { false }.
prolog pl_string_char(C) --> pl_quoted_char(C), !.
prolog pl_string_char(C) --> [C].

test pl_regular_term :-
    pl_regular_term(123, "123", ""),
    pl_regular_term(hi, "hi", ""),
    pl_regular_term(hi(1), "hi(1)", ""),
    pl_regular_term(hi(b, 4), "hi(b, 4)", ""),
    pl_regular_term(6, "(6)", ""),
    pl_regular_term('{}'(x), "{x}", ""),
    pl_regular_term([], "[]", ""),
    pl_regular_term([1,2,3], "[1,2,3]", "").

prolog pl_comma_separated(As, Tail, End) -->
    pl_comma_seperated_first(As, Tail, End).

prolog pl_comma_seperated_first(Tail, Tail, End) -->
    End, !.
prolog pl_comma_seperated_first([A | As], Tail, End) -->
    pl_expression(1000, A), !,
    pl_comma_separated_next(As, Tail, End).

prolog pl_comma_separated_next(Tail, Tail, End) -->
    End, !.
prolog pl_comma_separated_next([A | As], Tail, End) -->
    require(pl_token(",")), !,
    pl_expression(1000, A), !,
    pl_comma_separated_next(As, Tail, End).

prolog pl_op_or_term('!', term) --> "!", pl_skipwhite.
prolog pl_op_or_term(X, Info) -->
    pl_regular_term(X), !,
    ( { pl_op(Prec, Assoc, X), Info = op(Prec, Assoc) }
    ; { Info = term } ).
prolog pl_op_or_term(X, Info) -->
    many1(pl_op_char, Cs),
    ( pl_known_op(Cs, X, Prec, Assoc),
      { Info = op(Prec, Assoc) }
    % ; { atom_codes(X, Cs),
    %     Info = term }
    ),
    pl_skipwhite.

test pl_op_or_term :-
    \+ pl_op_or_term(A, op(B, C), "1", []).

prolog pl_known_op(Cs, Op, Prec, Assoc) --> { atom_codes(Op, Cs), pl_op(_, _, Op), !, pl_op(Prec, Assoc, Op) }.
prolog pl_known_op(Cs, Op, Prec, Assoc) --> { append(Shorter, [C], Cs) }, append([C]), pl_known_op(Shorter, Op, Prec, Assoc).

prolog pl_op_char(C) -->
    [C], { member(C, "`~!@#$%^&*<>?/;:-_=+,|\\.") }, !.

prolog pl_expression(none, Prec, Term) -->
    pl_op_or_term(Op, op(OpPrec, Assoc)),
    { member(Assoc-N, [fx-0, fy-1]),
      RightPrec is OpPrec + N },
    try(pl_expression(none, RightPrec, Right)),
    { Combined =.. [Op, Right] },
    pl_expression(just(Combined), Prec, Term).
prolog pl_expression(none, Prec, Term) --> !,
    require(pl_op_or_term(Left, term)),
    pl_expression(just(Left), Prec, Term).
prolog pl_expression(just(Left), Prec, Term) -->
    pl_op_or_term(Op, op(OpPrec, Assoc)),
    { member(Assoc-N, [xf-0, yf-1]),
      LeftPrec is OpPrec + N,
      LeftPrec < Prec,
      !,
      Combined =.. [Op, Left] },
    pl_expression(just(Combined), Prec, Term).
prolog pl_expression(just(Left), Prec, Term) -->
    pl_op_or_term(Op, op(OpPrec, Assoc)),
    { member(Assoc-N-M, [xfx-0-0, xfy-0-1, yfx-1-0]),
      LeftPrec is OpPrec + N,
      LeftPrec < Prec,
      !,
      RightPrec is OpPrec + M },
    require(pl_expression(none, RightPrec, Right)),
    { Combined =.. [Op, Left, Right] },
    pl_expression(just(Combined), Prec, Term).
prolog pl_expression(just(Term), _, Term) --> !.


prolog pl_op(1200, xfx, ':-') :- true.
prolog pl_op(1200, xfx, '-->') :- true.
prolog pl_op(1200, fx, ':-') :- true.
prolog pl_op(1105, xfy, '|') :- true.
prolog pl_op(1100, xfy, ';') :- true.
prolog pl_op(1050, xfy, '->') :- true.
prolog pl_op(1000, xfy, ',') :- true.
prolog pl_op(900, fy, '\\+') :- true.
prolog pl_op(700, xfx, '=') :- true.
prolog pl_op(700, xfx, '\\=') :- true.
prolog pl_op(700, xfx, '=..') :- true.
prolog pl_op(700, xfx, '==') :- true.
prolog pl_op(700, xfx, '\\==') :- true.
prolog pl_op(700, xfx, 'is') :- true.
prolog pl_op(700, xfx, '<') :- true.
prolog pl_op(700, xfx, '>') :- true.
prolog pl_op(700, xfx, '=<') :- true.
prolog pl_op(700, xfx, '>=') :- true.
prolog pl_op(700, xfx, '=\\=') :- true.
prolog pl_op(600, xfy, ':') :- true.
prolog pl_op(500, yfx, '+') :- true.
prolog pl_op(500, yfx, '-') :- true.
prolog pl_op(400, yfx, '*') :- true.
prolog pl_op(400, yfx, '/') :- true.
prolog pl_op(400, yfx, 'rem') :- true.
prolog pl_op(400, yfx, 'mod') :- true.
prolog pl_op(400, yfx, 'div') :- true.
prolog pl_op(400, yfx, '<<') :- true.
prolog pl_op(400, yfx, '>>') :- true.
prolog pl_op(200, xfx, '**') :- true.
prolog pl_op(200, xfx, '^') :- true.
prolog pl_op(200, fy, '+') :- true.
prolog pl_op(200, fy, '-') :- true.

%test parse_stage1 :-
%    read_file('stage1.pl', Bytes), !,
%    pl_top_level(_Decls, Bytes, []).

%% Extol

prolog xtl_token(N) --> N, xtl_skipwhite, !.

test xtl_token :-
    xtl_token("x", "x  ", ""),
    xtl_token("x", "x % comment", ""),
    xtl_token("x", "x % comment\n  \t", "").

prolog xtl_skipwhite --> xtl_white, !.
prolog xtl_skipwhite --> [].

test xtl_skipwhite :-
    xtl_skipwhite("", "").

prolog xtl_white --> "%", !, xtl_line_comment_, xtl_skipwhite.
prolog xtl_white --> (" "; "\t"; "\r" ; "\n" ), !, xtl_skipwhite.

test xtl_white :-
    xtl_white(" ", ""),
    xtl_white("%", ""),
    xtl_white("% comment \n\t  ", "").

prolog xtl_line_comment_ --> ("\n" ; eof), !.
prolog xtl_line_comment_ --> [_], xtl_line_comment_.

dcg xtl_top_level:
contract((Decls), true, list(Decls)),
((Decls):
    ( "#!", !, xtl_line_comment_; { true }),
    xtl_skipwhite,
    many(xtl_declaration, Decls),
    require(eof)).

dcg xtl_declaration:
((_): eof, !, {fail}),
((Decl): xtl_expression(DeclV), { xtl_makevars(DeclV, Decl, _) }, require(xtl_token("."))).

test xtl_declaration :-
    xtl_declaration(Decl, "f: (x: 1), (y: 2, 3).", ""),
    Decl = (f: ((x: 1), (y: (2, 3)))).

prolog xtl_makevars(V, _, _) :-
    V =.. ['XTL$VARNAME', '_'], !.
prolog xtl_makevars(V, Var, Vars) :-
    V =.. ['XTL$VARNAME', Name], !,
    member(Name-Var, Vars), !.
prolog xtl_makevars(Atomic, Atomic, _) :-
    atomic(Atomic), !.
prolog xtl_makevars([X|Xs], [Y|Ys], Vars) :- !,
    xtl_makevars(X, Y, Vars),
    xtl_makevars(Xs, Ys, Vars).
prolog xtl_makevars(In, Out, Vars) :-
    In =... InL, !,
    xtl_makevars(InL, OutL, Vars),
    Out =... OutL.

test xtl_makevars :-
    A =.. ['XTL$VARNAME', 'A'],
    xtl_makevars(foo(A, A), foo(1, Z), V),
    atomic(Z),
    Z = 1.

dcg xtl_atom_char:
contract((Byte), true, number(Byte)),
(C:
    [C], !,
    { member(C, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789$?") }).

prolog xtl_atom(Atom) -->
    "'",
    xtl_quoted_atom_chars_(Cs),
    { atom_codes(Atom, Cs) }.
prolog xtl_atom(AtomVar) -->
    many1(xtl_atom_char, Cs), !,
    { atom_codes(Atom, Cs),
      Cs = [C|_],
      ( C = 0'_, !,
        AtomVar =.. ['XTL$VARNAME', '_']
      ; member(C, "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
        !, AtomVar =.. ['XTL$VARNAME', Atom]
      ; AtomVar = Atom )}.

test xtl_atom :-
    xtl_atom(a, "'a'", ""),
    xtl_atom('+', "'+'", ""),
    xtl_atom('9', "'\\9'", ""),
    xtl_atom(ab, "ab", ""),
    xtl_atom('ab?', "ab?", "").

dcg xtl_quoted_char:
% contract((Bytes), true, number(Byte)),
((C) :
    "\\", !,
    require([Quoted]),
    { member(Quoted - C, [
                 0'n - 10,
                 0'r - 13,
                 0't - 9,
                 0'e - 127,
                 AsIs - AsIs
    ]) }, !).

prolog xtl_quoted_atom_chars_([]) --> "'", !.
prolog xtl_quoted_atom_chars_([C | Cs]) -->
    xtl_quoted_char(C), !,
    xtl_quoted_atom_chars_(Cs).
prolog xtl_quoted_atom_chars_([C | Cs]) -->
    [C],
    xtl_quoted_atom_chars_(Cs).

prolog xtl_expression(Expr) -->
    xtl_expression(1201, Expr).

dcg xtl_expression:
contract((Prec, Expr), number(Prec), true),
((Prec, Expr):
    xtl_expression(none, Prec, Expr)).

test xtl_expression :-
    xtl_expression(1, "1", []),
    xtl_expression(a, "a", []),
    xtl_expression(a + b, "a + b", []),
    xtl_expression(a + (b * c), "a + b * c", []),
    xtl_expression((a * b) + c, "a * b + c", []),
    xtl_expression((-a) * b, "-a * b", []),
    xtl_expression((:- (a * b)), ":- a * b", []),
    xtl_expression('()', "( )", []),
    xtl_expression(':'(x, ':'('()', y)), "x: ((): y)", []).

test comma_expr :-
    xtl_expression((p :- (a, b)), "p :- a, b", []).

prolog xtl_regular_term(Char) --> "0'", !, require(xtl_string_char(Char)), xtl_skipwhite.
prolog xtl_regular_term(Integer) -->
    many1(digit, Ds), !,
    { foldl(add_digit, 0, Ds, Integer) },
    xtl_skipwhite.
prolog xtl_regular_term(String) --> "\"", !, require(many(xtl_string_char, String)), require("\""), xtl_skipwhite.
prolog xtl_regular_term(Term) -->
    xtl_atom(Atom), !,
    ( xtl_token("("), !,
      xtl_comma_separated(Args, [], xtl_token(")")),
      { Term =.. [Atom | Args] }
    ; xtl_skipwhite,
      { Term = Atom }).
prolog xtl_regular_term('()') -->
    xtl_token("("),
    xtl_token(")"), !.
prolog xtl_regular_term(Term) -->
    xtl_token("("),
    xtl_expression(Term),
    require(xtl_token(")")).
prolog xtl_regular_term('{}'(Term)) -->
    xtl_token("{"),
    xtl_expression(Term),
    require(xtl_token("}")).
prolog xtl_regular_term(Term) -->
    xtl_token("["),
    xtl_comma_separated(Term, Tail,
                       ( xtl_token("]"), {Tail=[]}
                       ; xtl_token("|"), xtl_expression(Tail), xtl_token("]"))), !.

dcg xtl_string_char:
contract((Byte), true, byte(Byte)),
((_): "\"", !, { false }),
((C): xtl_quoted_char(C), !),
((C): [C]).

test xtl_regular_term :-
    xtl_regular_term(123, "123", ""),
    xtl_regular_term(hi, "hi", ""),
    xtl_regular_term(hi(1), "hi(1)", ""),
    xtl_regular_term(hi(b, 4), "hi(b, 4)", ""),
    xtl_regular_term(6, "(6)", ""),
    xtl_regular_term('{}'(x), "{x}", ""),
    xtl_regular_term([], "[]", ""),
    xtl_regular_term([1,2,3], "[1,2,3]", "").

prolog xtl_comma_separated(As, Tail, End) -->
    xtl_comma_seperated_first(As, Tail, End).

prolog xtl_comma_seperated_first(Tail, Tail, End) -->
    End, !.
prolog xtl_comma_seperated_first([A | As], Tail, End) -->
    xtl_expression(1000, A), !,
    xtl_comma_separated_next(As, Tail, End).

prolog xtl_comma_separated_next(Tail, Tail, End) -->
    End, !.
prolog xtl_comma_separated_next([A | As], Tail, End) -->
    require(xtl_token(",")), !,
    xtl_expression(1000, A), !,
    xtl_comma_separated_next(As, Tail, End).

prolog xtl_op_or_term('!', term) --> "!", xtl_skipwhite.
prolog xtl_op_or_term(X, Info) -->
    xtl_regular_term(X), !,
    ( { xtl_op(Prec, Assoc, X), Info = op(Prec, Assoc) }
    ; { Info = term } ).
prolog xtl_op_or_term(X, Info) -->
    many1(xtl_op_char, Cs),
    ( xtl_known_op(Cs, X, Prec, Assoc),
      { Info = op(Prec, Assoc) }
    % ; { atom_codes(X, Cs),
    %     Info = term }
    ),
    xtl_skipwhite.

prolog xtl_known_op(Cs, Op, Prec, Assoc) --> { atom_codes(Op, Cs), xtl_op(_, _, Op), !, xtl_op(Prec, Assoc, Op) }.
prolog xtl_known_op(Cs, Op, Prec, Assoc) --> { append(Shorter, [C], Cs) }, append([C]), xtl_known_op(Shorter, Op, Prec, Assoc).

prolog xtl_op_char(C) -->
    [C], { member(C, "`~!@#%^&*<>/;:-_=+,|\\.") }, !.

prolog xtl_expression(none, Prec, Term) -->
    xtl_op_or_term(Op, op(OpPrec, Assoc)),
    { member(Assoc-N, [fx-0, fy-1]),
      RightPrec is OpPrec + N },
    try(xtl_expression(none, RightPrec, Right)),
    { Combined =.. [Op, Right] },
    xtl_expression(just(Combined), Prec, Term).
prolog xtl_expression(none, Prec, Term) --> !,
    require(xtl_op_or_term(Left, term)),
    xtl_expression(just(Left), Prec, Term).
prolog xtl_expression(just(Left), Prec, Term) -->
    xtl_op_or_term(Op, op(OpPrec, Assoc)),
    { member(Assoc-N, [xf-0, yf-1]),
      LeftPrec is OpPrec + N,
      LeftPrec < Prec,
      !,
      Combined =.. [Op, Left] },
    xtl_expression(just(Combined), Prec, Term).
prolog xtl_expression(just(Left), Prec, Term) -->
    xtl_op_or_term(Op, op(OpPrec, Assoc)),
    { member(Assoc-N-M, [xfx-0-0, xfy-0-1, yfx-1-0]),
      LeftPrec is OpPrec + N,
      LeftPrec < Prec,
      !,
      RightPrec is OpPrec + M },
    require(xtl_expression(none, RightPrec, Right)),
    { Combined =.. [Op, Left, Right] },
    xtl_expression(just(Combined), Prec, Term).
prolog xtl_expression(just(Term), _, Term) --> !.

prolog xtl_op(1200, xfx, ':-') :- true.
prolog xtl_op(1200, xfx, '-->') :- true.
prolog xtl_op(1200, fx, ':-') :- true.
prolog xtl_op(1105, xfy, '|') :- true.
prolog xtl_op(1100, xfy, ';') :- true.
prolog xtl_op(1050, xfy, '->') :- true.
prolog xtl_op(1000, xfy, ',') :- true.
prolog xtl_op(900, fy, '\\+') :- true.
prolog xtl_op(700, xfx, '=') :- true.
prolog xtl_op(700, xfx, '\\=') :- true.
prolog xtl_op(700, xfx, '=..') :- true.
prolog xtl_op(700, xfx, '==') :- true.
prolog xtl_op(700, xfx, '\\==') :- true.
prolog xtl_op(700, xfx, 'is') :- true.
prolog xtl_op(700, xfx, '<') :- true.
prolog xtl_op(700, xfx, '>') :- true.
prolog xtl_op(700, xfx, '=<') :- true.
prolog xtl_op(700, xfx, '>=') :- true.
prolog xtl_op(700, xfx, '=\\=') :- true.
prolog xtl_op(500, yfx, '+') :- true.
prolog xtl_op(500, yfx, '-') :- true.
prolog xtl_op(400, yfx, '*') :- true.
prolog xtl_op(400, yfx, '/') :- true.
prolog xtl_op(400, yfx, 'rem') :- true.
prolog xtl_op(400, yfx, 'mod') :- true.
prolog xtl_op(400, yfx, 'div') :- true.
prolog xtl_op(400, yfx, '<<') :- true.
prolog xtl_op(400, yfx, '>>') :- true.
prolog xtl_op(200, xfx, '**') :- true.
prolog xtl_op(200, xfx, '^') :- true.
prolog xtl_op(200, fy, '+') :- true.
prolog xtl_op(200, fy, '-') :- true.

prolog xtl_op(1200, fy, test) :- true.
prolog xtl_op(1200, fy, prolog) :- true.
prolog xtl_op(999, fx, tc) :- true.
prolog xtl_op(700, xfx, '=...') :- true.
prolog xtl_op(1200, xfx, ':') :- true.
prolog xtl_op(1150, fy, dcg) :- true.
prolog xtl_op(1150, fy, pred) :- true.

pred '=...':
contract((F, A), (compound(F); atom(F); A = [G | _], atom(G)), true),
((F, A) : F =.. A).

test parse_self :-
    read_file('main.xtl', Bytes), !,
    xtl_top_level(_Decls, Bytes, []).

%% Extol to Prolog

prolog xtl_to_pl_toplevel(XTL, PL) :-
    maplist(must(xtl_to_pl_declaration), XTL, DeclsPL),
    append(DeclsPL, FlatDeclsPL),
    append([
                  (:- set_prolog_flag(singleton_warning, off)),
                  (:- discontiguous('/'('test', 1))),
                  (:- initialization((main;write('error: unexpected failure in main'),nl,halt(1))))
              ], FlatDeclsPL, PL).

% xtl_to_pl_declaration(XTL, PL) :- t(to_pl_declaration(XTL)), false.
prolog xtl_to_pl_declaration(prolog((HeadXTL :- GoalXTL)), [(HeadPL :- GoalPL)]) :- !,
    copy_term(HeadXTL-GoalXTL, HeadPL-Goal),
    xtl_to_pl_goal(Goal, GoalPL),
    numbervars(HeadPL-GoalPL).

prolog xtl_to_pl_declaration((test XTL), [test PL]) :- !,
    xtl_to_pl_goal(XTL, PL),
    numbervars(PL).

prolog xtl_to_pl_declaration(prolog((N --> L)), [(NPL :- LPL)]) :- !,
     N =... [F|A],
     append(A, [I, O], AIO),
     NPL =... [F|AIO],
     xtl_to_pl_dcg(L, LPL, I, O),
     numbervars(NPL-LPL).

prolog xtl_to_pl_declaration((Pred: Defs), Decls) :- !,
    comma_list(Defs, Xs),
    ( xtl_def_contract(Xs, Contract, Rest),
      Pred =... [Type, Name],
      atom_concat('__contract_free_', Name, InnerName),
      Head =... [Type, InnerName],
      maplist(xtl_def_to_pl(Head), Rest, InnerDecls),
      xtl_contract_to_pl(Pred, InnerName, Contract, OuterDecls),
      append(OuterDecls, InnerDecls, Decls)
    ; maplist(xtl_def_to_pl(Pred), Xs, Decls)).

prolog xtl_to_pl_declaration(X, _) :- !, throw(error(unknown_declaration(X))).

test xtl_to_pl_declaration :-
    xtl_to_pl_declaration(
        (pred odd:
         (0: false),
         (1: true),
         (N: M is N - 2, odd(M))),
        Res1),
    Res1 = [(odd(0) :- false),
           (odd(1) :- true),
           (odd(NN) :- MM is NN - 2, odd(MM))],

    xtl_to_pl_declaration((dcg(f): (x: [x])), Res2),
    Res2 = [(f(x,I,O) :- append([x],O,I))],

    xtl_to_pl_declaration((pred f: contract(a, b, c), (d: e)), Res3),
    Res3 = [
        (f(a) :- assert(b),
                 '__contract_free_f'(a),
                 assert(c)),
        ('__contract_free_f'(d) :- e)],

    xtl_to_pl_declaration((dcg f: contract(a, b, c), (d: e)), Res4),
    Res4 = [
        (f(a,A,B) :-
             assert(b),
             '__contract_free_f'(a,A,B),
             assert(c)),
        ('__contract_free_f'(d,A,B) :- e(A,B))],

    xtl_to_pl_declaration((pred f: ((): g, h)), Res5),
    Res5 = [(f :- g, h)].

pred xtl_def_contract: (([Contract|Rest], Contract, Rest): Contract = contract(_,_,_)).

prolog xtl_def_to_pl(dcg(Pred), (Head: Body), (HeadPL :- GoalPL)) :-
    copy_term(Head-Body, HeadVars-Goal),
    comma_list(HeadVars, HeadArgs),
    append(HeadArgs, [I,O], HeadIO),
    HeadPL =.. [Pred | HeadIO],
    xtl_to_pl_dcg(Goal, GoalPL, I, O),
    numbervars(HeadPL-GoalPL).
prolog xtl_def_to_pl(pred(Pred), (Head: Body), (HeadPL :- GoalPL)) :-
    copy_term(Head-Body, HeadVars-Goal),
    comma_list(HeadVars, HeadArgs),
    HeadPL =.. [Pred | HeadArgs],
    xtl_to_pl_goal(Goal, GoalPL),
    numbervars(HeadPL-GoalPL).

prolog xtl_to_pl_goal(Var, call(Var)) :-
    var(Var), !.
prolog xtl_to_pl_goal((A, B), (APL, BPL)) :- !,
    xtl_to_pl_goal(A, APL),
    xtl_to_pl_goal(B, BPL).
prolog xtl_to_pl_goal((A; B), (APL; BPL)) :- !,
    xtl_to_pl_goal(A, APL),
    xtl_to_pl_goal(B, BPL).
prolog xtl_to_pl_goal((A -> B ; C), (APL -> BPL ; CPL)) :- !,
    xtl_to_pl_goal(A, APL),
    xtl_to_pl_goal(B, BPL),
    xtl_to_pl_goal(C, CPL).
prolog xtl_to_pl_goal((A -> B), (APL -> BPL)) :- !,
    xtl_to_pl_goal(A, APL),
    xtl_to_pl_goal(B, BPL).
prolog xtl_to_pl_goal('!', '!') :- !.
prolog xtl_to_pl_goal(G, GPL) :-
    G = GPL.

prolog xtl_to_pl_dcg(Var, dcg_call(Var, I, O), I, O) :-
    var(Var), !.
prolog xtl_to_pl_dcg((A, B), (APL, BPL), I, O) :- !,
    xtl_to_pl_dcg(A, APL, I, IO),
    xtl_to_pl_dcg(B, BPL, IO, O).
prolog xtl_to_pl_dcg((A; B), (APL; BPL), I, O) :- !,
    xtl_to_pl_dcg(A, APL, I, O),
    xtl_to_pl_dcg(B, BPL, I, O).
prolog xtl_to_pl_dcg((!), (!, I=O), I, O) :- !.
prolog xtl_to_pl_dcg([], (I=O), I, O) :- !.
prolog xtl_to_pl_dcg([X|XS], append([X|XS], O, I), I, O) :- !.
prolog xtl_to_pl_dcg({G}, (GPL, I=O), I, O) :- !,
    xtl_to_pl_goal(G, GPL).
prolog xtl_to_pl_dcg(F, C, I, O) :- !,
    F =... L,
    append(L, [I,O], LL),
    C =... LL.
prolog xtl_to_pl_dcg(D,_,_,_) :-
    throw(error(xtl_to_pl_dcg, D)).

test xtl_to_pl_dcg :-
    xtl_to_pl_dcg(((f; g), h), ((f(a, b); g(a, b)), h(b, c)), a, c),
    xtl_to_pl_dcg((e, (f, i; g), h), (e(a, b), (f(b, c), i(c, d); g(b, d)), h(d, e)), a, e),
    xtl_to_pl_dcg(V, PL1, i, o),
    PL1 == dcg_call(V, i, o),
    xtl_to_pl_dcg({V}, PL2, i, o),
    PL2 == (call(V), i = o).

test xtl_to_pl_dcg_regression :-
    XTL = (
        prolog((c_declaration(declare(Name, Type, Value)) -->
            c_type(Type),
            [symbol(Name)],
            ( [operator('=')],
              c_value(Assign),
              !,
              { Value = value(Assign) }
            ; { Value = none } ),
            [operator(';')]))),
    xtl_to_pl_declaration(XTL, [PL]),
    PL = (c_declaration(declare(A,B,C),D,E) :-
              c_type(B,D,F),
              append([symbol(A)],G,F),
              ( append([operator('=')], H, G),
                c_value(I,H,J),
                (!, J = K),
                (C = value(I), K = L)
              ; C = none,
                G = L),
              append([operator(';')], M, L)).

prolog xtl_contract_to_pl(pred(Name), InnerName, contract(Args, Expects, Ensures), [DeclsPL]) :-
    comma_list(Args, ArgsList),
    Head =... [Name | ArgsList],
    xtl_to_pl_goal(Expects, ExpectsPL),
    xtl_to_pl_goal(Ensures, EnsuresPL),
    Inner =... [InnerName | ArgsList],
    Decls = (Head :-
                 assert(Expects),
                 Inner,
                 assert(Ensures)),
    copy_term(Decls, DeclsPL),
    numbervars(DeclsPL).

prolog xtl_contract_to_pl(dcg(Name), InnerName, contract(Args, Expects, Ensures), Result) :-
    comma_list(Args, ArgsList),
    append(ArgsList, [_,_], ArgsListIO),
    comma_list(ArgsIO, ArgsListIO),
    xtl_contract_to_pl(pred(Name), InnerName, contract(ArgsIO, Expects, Ensures), Result).

prolog error_unless(Goal, _) :-
    call(Goal), !.
prolog error_unless(_, Error) :-
    throw(error(Error)).
prolog error_unless(Goal) :-
    error_unless(Goal, goal_failed(Goal)).

pred xtl_repl:
    ((): write('Extol> '), flush_output, read_line(Line),
    ( Line = [0'\n]
    ; catch((
        xtl_expression(ExpV, Line, []),
        xtl_makevars(ExpV, Exp, Vars),
        
        xtl_to_pl_goal(Exp, ExpPL),
        call(ExpPL),
        repl_write_result(Vars)
      ), Exception, (
        write('failed: '), write(Exception), nl
      ))
    ; write(error), nl),
    !, xtl_repl),
    ((): write('end'), nl).

pred repl_write_result:
(([]): true),
(([(V-X) | Xs]): write(V), write(' = '), write(X), nl).