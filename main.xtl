%% Header

:- discontiguous('/'('test', 1)).
:- discontiguous('/'('type', 1)).
:- discontiguous('/'('typed', 1)).

%% Debugging

% Trace
t(X) :- write('trace: '), ti, writeq(X), nl.
t(X, A, A) :-
    write('trace: '), ti, writeq(X), write(', at: '),
    pretty_init(A, C), write(C),
    nl, ! .

pretty_init(A, C) :-
    copy_term(A, AA),
    (length(B, 32), append(B, _, AA) ; B = AA), !,
    prep_chars(B, Q, []),
    length(Q, N),
    (N < 10 -> append(Q, "<eof>", QQ) ; QQ = Q),
    atom_codes(C, QQ).

prep_chars([]) --> [].
prep_chars([X | Xs]) --> prep_char(X), prep_chars(Xs).

prep_char(X) --> { var(X) }, !, "<?>".
prep_char(0'\n) --> !, "<nl>".
prep_char(0'\r) --> !, "<cr>".
prep_char(0'\t) --> !, "<tab>".
prep_char(0'<) --> !, "<lt>".
prep_char(X) -->
    { ( \+integer(X) ; X < 32 ; X > 126), !,
      open_output_codes_stream(S),
      write(S, X),
      close_output_codes_stream(S, C) },
    "<", dcg_call(C), ">", !.
prep_char(X) --> [X].

% Trace and fail
tf(X) :- t(X), fail.
tf(X, A, B) :- tf(X, A, B), fail.

% Trace call
tc(F) :-
    undo(t(failed(F))),
    t(enter(F)),
    ticall(F),
    undo(t(redo(F))),
    t(exit(F)).

tc(F) -->
    undo(t(failed(F))),
    t(enter(F)),
    ticall(F),
    undo(t(redo(F))),
    t(exit(F)).

tc(F, X) -->
    undo(t(failed(F))),
    t(enter(F)),
    ticall(F, X),
    undo(t(redo(F))),
    t(exit(F)).

% Trace indent

ti :-
    Pat = [0'|, 0' , 0'., 0' , 0'., 0'  | Pat],
    g_read(tindent, I),
    II is I * 2,
    length(L, II),
    append(L, _, Pat),
    atom_codes(S, L),
    write(S).

ticall(G) :-
    g_read(tindent, I),
    II is I + 1,
    g_assignb(tindent, II),
    call(G),
    g_assignb(tindent, I).

ticall(G, A, B) :-
    g_read(tindent, I),
    II is I + 1,
    g_assignb(tindent, II),
    dcg_call(G, A, B),
    g_assignb(tindent, I).

ticall(G, X, A, B) :-
    g_read(tindent, I),
    II is I + 1,
    g_assignb(tindent, II),
    G =.. L,
    append(L, [X], LL),
    GX =.. LL,
    dcg_call(GX, A, B),
    g_assignb(tindent, I).

% Call on undo

undo(_).
undo(G) :- call(G), fail.

undo(_, A, A).
undo(G, A, B) :- call(G, A, B), fail.

%% Types

type(stream) :- unique(stream).
type(byte) :- unique(byte).
type(list(T)) :- constructors([
       ['[]'],
       ['.', T, list(T)]
     ]).
type(bytes) :- list(byte).

%% Streams

typed(read_bytes(+stream, -bytes)).
read_bytes(Stream, []) :- at_end_of_stream(Stream), !.
read_bytes(Stream, [X | Xs]) :-
    get_byte(Stream, X),
    read_bytes(Stream, Xs).

typed(write_bytes(+stream, +bytes)).
write_bytes(_, []).
write_bytes(Stream, [X | Xs]) :-
    put_byte(Stream, X),
    write_bytes(Stream, Xs).

typed(read_file(+atom, -bytes)).
read_file(Path, Bytes) :-
    open(Path, read, Stream, [type(binary), buffering(block)]),
    read_bytes(Stream, Bytes),
    close(Stream).

typed(write_file(+atom, +bytes)).
write_file(Path, Bytes) :-
    open(Path, write, Stream, [type(binary), buffering(block)]),
    write_bytes(Stream, Bytes),
    close(Stream).

%% Main

:- initialization(main).

main :-
    current_prolog_flag(argv, [_, Command | Args]),
    command(Command, Args).

typed(command(atom, list(atom))).
command(test, Args) :-
    undo(halt),
    write('Running tests'), nl,
    test((Name :- Goals)),
    ([Name] = Args ; Args = []),
    write(Name), write('...'),
    once(run_test(Goals)),
    fail.

command(extoltoprolog, [In, Out]) :-
    read_file(In, BytesIn), !,
    xtl_top_level(DeclsXTL, BytesIn, []), !,
    %% xtl_check_types(DeclsXTL),
    xtl_to_pl_toplevel(DeclsXTL, DeclsPL),
    pl_write_top_level(DeclsPL, BytesGen, []), !,
    append("% Generated by extoltoprolog\n", BytesGen, BytesOut),
    write_file(Out, BytesOut).

run_test(done) :- !, write(success), nl.
run_test((A, B)) :- !,
    call(A)
    -> run_test(B)
    ; nl, write('  failed: '), write(A), nl.
run_test(B) :-
    run_test((B, done)).

:- discontiguous('/'('test', 1)).

test 'test_c' :-
    read_file('test.c', Bytes), !,
    c_pp([], Tokens, Bytes, []), !,
    c_top_level(_Decls, Tokens, []).

%% Parsing

typed(many(+predicate(T), -list(T), +bytes, -bytes)).
many(P, [X | Xs]) --> call(P, X), many(P, Xs), !.
many(_, []) --> [].

typed(many1(+predicate(T), -list(T), +bytes, -bytes)).
many1(P, [X | Xs]) --> call(P, X), !, many(P, Xs).

typed(eof(+bytes, -bytes)).
eof([], []).

typed(peek(-bytes, +bytes, -bytes)).
peek(Rest, Rest, Rest).

typed(alpha(-byte, +bytes, -bytes)).
alpha(C) --> [C], { member(C, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") }.

typed(digit(-byte, +bytes, -bytes)).
digit(D) -->
    [C],
    { member(C - D, [0'0 - 0, 0'1 - 1, 0'2 - 2, 0'3 - 3, 0'4 - 4, 0'5 - 5, 0'6 - 6, 0'7 - 7, 0'8 - 8, 0'9 - 9]) }.

typed(dcg_call(+sentence, +bytes, -bytes)).
dcg_call(Var) --> { var(Var), !, fail }.
dcg_call([]) --> !, [].
dcg_call([X | Xs]) --> !, [X], dcg_call(Xs).
dcg_call((A, B)) --> !, dcg_call(A), dcg_call(B).
dcg_call((A ; _)) --> dcg_call(A).
dcg_call((_ ; B)) --> !, dcg_call(B).
dcg_call({A}) --> !, { call(A) }.
dcg_call(G, In, Rest) :- !, call(G, In, Rest).

typed(require(+sentence, +bytes, -bytes)).
require(N, Xs, Rest) :-
    ( dcg_call(N, Xs, Rest), !
    ; pretty_init(Xs, C), throw(parse_failed(N, C)) ).

typed(try(+sentence, +bytes, -bytes)).
try(N, Xs, Rest) :- catch(dcg_call(N, Xs, Rest), parse_failed(_, _), Failed=true), !, Failed=false.

%% Lists

typed(foldl(+predicate(T, U, V), '?'(T), +list(U), '?'(V))).
foldl(_, R, [], R).
foldl(F, Z, [X | Xs], RR) :- call(F, Z, X, R), foldl(F, R, Xs, RR).

%% C preprocessor

c_pp(Env, Tokens) -->
    c_pp_lines(Lines), eof, !,
    { c_pp_eval(Env, Lines, Tokens, []) }.

c_pp_lines([]) --> eof, !.
c_pp_lines([Line | Lines]) --> c_pp_line(Line), !, c_pp_lines(Lines).

c_pp_line([]) --> c_pp_skipwhite, ("\n", ! ; eof), !.
c_pp_line([Token | Tokens]) --> c_pp_skipwhite, !, c_pp_token(Token), !, c_pp_line(Tokens).

c_pp_skipwhite --> c_pp_white, !.
c_pp_skipwhite --> [].

c_pp_white --> "//", !, c_pp_line_comment_.
c_pp_white --> "/*", !, c_pp_block_comment_, c_pp_skipwhite.
c_pp_white --> (" "; "\t"; "\r" ; "\\\r\n" ; "\\\n"), !, c_pp_skipwhite.

c_pp_line_comment_ --> (peek([0'\n | _]) ; eof), !.
c_pp_line_comment_ --> c_pp_white, !, c_pp_line_comment_.
c_pp_line_comment_ --> [_], !, c_pp_line_comment_.

c_pp_block_comment_ --> "*/", !.
c_pp_block_comment_ --> [_], c_pp_block_comment_.

c_pp_token(Token) --> (c_pp_operator(Token) ; c_pp_symbol(Token) ; c_pp_integer(Token)), !.

c_pp_operator(operator(Token), Next, Rest) :-
    member(Op, [
               "=",
               "#", ";"
    ]),
    append(Op, Rest, Next),
    atom_codes(Token, Op).

c_pp_symbol(symbol(Name)) --> c_pp_symbol_chars(Cs), { atom_codes(Name, Cs) }.

c_pp_symbol_chars([X | Xs]) --> c_pp_symbol_first(X), !, many(c_pp_symbol_char, Xs).

c_pp_symbol_first(C) --> alpha(C), !.
c_pp_symbol_first(0'_) --> "_".

c_pp_symbol_char(C) --> c_pp_symbol_first(C); [C], { member(C, "0123456789") }.

add_digit(N, D, R) :-
    member(D, [0,1,2,3,4,5,6,7,8,9]),
    ( var(N), N is R div D; true),
    R is N * 10 + D.

c_pp_integer(integer(N)) -->
    many1(digit, Ds), !,
    { foldl(add_digit, 0, Ds, N) }.

c_pp_eval(_, []) --> eof, !.
c_pp_eval(EnvA, [Line | Lines]) -->
    c_pp_eval_line(EnvA, EnvB, Line), !,
    c_pp_eval(EnvB, Lines).

c_pp_eval_line(Env, [Name = Value | Env], [operator('#'), symbol('define'), symbol(Name) | Value]) --> !.
c_pp_eval_line(Env, Env, []) --> !.
c_pp_eval_line(Env, Env, [symbol(X) | Xs]) -->
    { member(X = Ys, Env), !, append(Ys, Xs, Zs) },
    c_pp_eval_line(Env, Env, Zs).
c_pp_eval_line(Env, Env, [X | Xs]) -->
    [X],
    c_pp_eval_line(Env, Env, Xs).

%% C

c_top_level(Decls) --> many(c_declaration, Decls), eof.

c_declaration(declare(Name, Type, Value)) -->
    c_type(Type),
    [symbol(Name)],
    ( [operator('=')],
      c_value(Assign), !,
      { Value = value(Assign) }
    ; { Value = none } ),
    [operator(';')].

c_type(Type) --> [symbol(Type)].

c_value(variable(Name)) --> [symbol(Name)].
c_value(integer(N)) --> [integer(N)].

%% Prolog

pl_token(N) --> dcg_call(N), pl_skipwhite, !.

test pl_token :-
    pl_token("x", "x  ", ""),
    pl_token("x", "x % comment", ""),
    pl_token("x", "x % comment\n  \t", "").

pl_skipwhite --> pl_white, !.
pl_skipwhite --> [].

test pl_skipwhite :-
    pl_skipwhite("", "").

pl_white --> "%", !, pl_line_comment_, pl_skipwhite.
pl_white --> (" "; "\t"; "\r" ; "\n" ), !, pl_skipwhite.

test pl_white :-
    pl_white(" ", ""),
    pl_white("%", ""),
    pl_white("% comment \n\t  ", "").

pl_line_comment_ --> ("\n" ; eof), !.
pl_line_comment_ --> [_], pl_line_comment_.

pl_top_level(Decls) -->
    ( "#!", !, pl_line_comment_; { true }),
    pl_skipwhite,
    many(pl_declaration, Decls),
    require(eof).

pl_write_top_level([]) --> [].
pl_write_top_level([Decl | Decls]) -->
    pl_write_term(Decl), ".\n",
    pl_write_top_level(Decls).

pl_write_term(X) -->
    { open_output_codes_stream(Stream),
      write_term(Stream, X, [quoted(true), namevars(true), numbervars(true)]),
      close_output_codes_stream(Stream, Bytes) },
    dcg_call(Bytes).

pl_declaration(_) --> eof, !, {fail}.
pl_declaration(Decl) --> pl_expression(Decl), require(pl_token(".")).

pl_atom_char(C) -->
    [C], !,
    { member(C, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789") }.

pl_atom(Atom) -->
    "'",
    pl_quoted_atom_chars_(Cs),
    { atom_codes(Atom, Cs) }.
pl_atom(AtomVar) -->
    many1(pl_atom_char, Cs), !,
    { atom_codes(Atom, Cs),
      ( Cs = [C|_],
        member(C, "_ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
        !, AtomVar =.. ['$VARNAME', Atom]
      ; AtomVar = Atom )}.

test pl_atom :-
    pl_atom(a, "'a'", ""),
    pl_atom('+', "'+'", ""),
    pl_atom('9', "'\\9'", ""),
    pl_atom(ab, "ab", ""),
    pl_atom(ab, "ab", "").

pl_quoted_char(C) -->
    "\\", !,
    require([Quoted]),
    { member(Quoted : C, [
                 0'n : 10,
                 0'r : 13,
                 0't : 9,
                 0'e : 127,
                 AsIs : AsIs
    ]) }, !.

pl_quoted_atom_chars_([]) --> "'", !.
pl_quoted_atom_chars_([C | Cs]) -->
    pl_quoted_char(C), !,
    pl_quoted_atom_chars_(Cs).
pl_quoted_atom_chars_([C | Cs]) -->
    [C],
    pl_quoted_atom_chars_(Cs).

pl_expression(Expr) -->
    pl_expression(1201, Expr).

pl_expression(Prec, Expr) -->
    pl_expression(none, Prec, Expr).

test pl_expression :-
    pl_expression(1, "1", []),
    pl_expression(a, "a", []),
    pl_expression(a + b, "a + b", []),
    pl_expression(a + (b * c), "a + b * c", []),
    pl_expression((a * b) + c, "a * b + c", []),
    pl_expression((-a) * b, "-a * b", []),
    pl_expression((:- (a * b)), ":- a * b", []).

test pl_comma_expr :-
    pl_expression((p :- (a, b)), "p :- a, b", []).

pl_regular_term(Char) --> "0'", !, require(pl_string_char(Char)), pl_skipwhite.
pl_regular_term(Integer) -->
    many1(digit, Ds), !,
    { foldl(add_digit, 0, Ds, Integer) },
    pl_skipwhite.
pl_regular_term(String) --> "\"", !, require(many(pl_string_char, String)), require("\""), pl_skipwhite.
pl_regular_term(Term) -->
    pl_atom(Atom), !,
    ( pl_token("("), !,
      pl_comma_separated(Args, [], pl_token(")")),
      { Term =.. [Atom | Args] }
    ; pl_skipwhite,
      { Term = Atom }).
pl_regular_term(Term) -->
    pl_token("("),
    pl_expression(Term),
    require(pl_token(")")).
pl_regular_term('{}'(Term)) -->
    pl_token("{"),
    pl_expression(Term),
    require(pl_token("}")).
pl_regular_term(Term) -->
    pl_token("["),
    pl_comma_separated(Term, Tail,
                       ( pl_token("]"), {Tail=[]}
                       ; pl_token("|"), pl_expression(Tail), pl_token("]"))), !.

pl_string_char(_) --> "\"", !, { false }.
pl_string_char(C) --> pl_quoted_char(C), !.
pl_string_char(C) --> [C].

test pl_regular_term :-
    pl_regular_term(123, "123", ""),
    pl_regular_term(hi, "hi", ""),
    pl_regular_term(hi(1), "hi(1)", ""),
    pl_regular_term(hi(b, 4), "hi(b, 4)", ""),
    pl_regular_term(6, "(6)", ""),
    pl_regular_term('{}'(x), "{x}", ""),
    pl_regular_term([], "[]", ""),
    pl_regular_term([1,2,3], "[1,2,3]", "").

pl_comma_separated(As, Tail, End) -->
    pl_comma_seperated_first(As, Tail, End).

pl_comma_seperated_first(Tail, Tail, End) -->
    dcg_call(End), !.
pl_comma_seperated_first([A | As], Tail, End) -->
    pl_expression(1000, A), !,
    pl_comma_separated_next(As, Tail, End).

pl_comma_separated_next(Tail, Tail, End) -->
    dcg_call(End), !.
pl_comma_separated_next([A | As], Tail, End) -->
    require(pl_token(",")), !,
    pl_expression(1000, A), !,
    pl_comma_separated_next(As, Tail, End).

pl_op_or_term('!', term) --> "!", pl_skipwhite.
pl_op_or_term(X, Info) -->
    pl_regular_term(X), !,
    ( { pl_op(Prec, Assoc, X), Info = op(Prec, Assoc) }
    ; { Info = term } ).
pl_op_or_term(X, Info) -->
    many1(pl_op_char, Cs),
    ( pl_known_op(Cs, X, Prec, Assoc),
      { Info = op(Prec, Assoc) }
    % ; { atom_codes(X, Cs),
    %     Info = term }
    ),
    pl_skipwhite.

pl_known_op(Cs, Op, Prec, Assoc) --> { atom_codes(Op, Cs), pl_op(_, _, Op), !, pl_op(Prec, Assoc, Op) }.
pl_known_op(Cs, Op, Prec, Assoc) --> { append(Shorter, [C], Cs) }, append([C]), pl_known_op(Shorter, Op, Prec, Assoc).

pl_op_char(C) -->
    [C], { member(C, "`~!@#$%^&*<>?/;:-_=+,|\\.") }, !.

pl_expression(none, Prec, Term) -->
    pl_op_or_term(Op, op(OpPrec, Assoc)),
    { member(Assoc-N, [fx-0, fy-1]),
      RightPrec is OpPrec + N },
    try(pl_expression(none, RightPrec, Right)),
    { Combined =.. [Op, Right] },
    pl_expression(just(Combined), Prec, Term).
pl_expression(none, Prec, Term) --> !,
    require(pl_op_or_term(Left, term)),
    pl_expression(just(Left), Prec, Term).
pl_expression(just(Left), Prec, Term) -->
    pl_op_or_term(Op, op(OpPrec, Assoc)),
    { member(Assoc-N, [xf-0, yf-1]),
      LeftPrec is OpPrec + N,
      LeftPrec < Prec,
      !,
      Combined =.. [Op, Left] },
    pl_expression(just(Combined), Prec, Term).
pl_expression(just(Left), Prec, Term) -->
    pl_op_or_term(Op, op(OpPrec, Assoc)),
    { member(Assoc-N-M, [xfx-0-0, xfy-0-1, yfx-1-0]),
      LeftPrec is OpPrec + N,
      LeftPrec < Prec,
      !,
      RightPrec is OpPrec + M },
    require(pl_expression(none, RightPrec, Right)),
    { Combined =.. [Op, Left, Right] },
    pl_expression(just(Combined), Prec, Term).
pl_expression(just(Term), _, Term) --> !.


pl_op(1200, xfx, ':-').
pl_op(1200, xfx, '-->').
pl_op(1200, fx, ':-').
pl_op(1105, xfy, '|').
pl_op(1100, xfy, ';').
pl_op(1050, xfy, '->').
pl_op(1000, xfy, ',').
pl_op(900, fy, '\\+').
pl_op(700, xfx, '=').
pl_op(700, xfx, '\\=').
pl_op(700, xfx, '=..').
pl_op(700, xfx, '==').
pl_op(700, xfx, '\\==').
pl_op(700, xfx, 'is').
pl_op(700, xfx, '<').
pl_op(700, xfx, '>').
pl_op(700, xfx, '=<').
pl_op(700, xfx, '>=').
pl_op(700, xfx, '=\\=').
pl_op(600, xfy, ':').
pl_op(500, yfx, '+').
pl_op(500, yfx, '-').
pl_op(400, yfx, '*').
pl_op(400, yfx, '/').
pl_op(400, yfx, 'rem').
pl_op(400, yfx, 'mod').
pl_op(400, yfx, 'div').
pl_op(400, yfx, '<<').
pl_op(400, yfx, '>>').
pl_op(200, xfx, '**').
pl_op(200, xfx, '^').
pl_op(200, fy, '+').
pl_op(200, fy, '-').

%test parse_stage1 :-
%    read_file('stage1.pl', Bytes), !,
%    pl_top_level(_Decls, Bytes, []).

%% Extol

typed(xtl_token(+sentence), +bytes, -bytes).
xtl_token(N) --> dcg_call(N), xtl_skipwhite, !.

test xtl_token :-
    xtl_token("x", "x  ", ""),
    xtl_token("x", "x % comment", ""),
    xtl_token("x", "x % comment\n  \t", "").

typed(xtl_skipwhite(+bytes, -bytes)).
xtl_skipwhite --> xtl_white, !.
xtl_skipwhite --> [].

test xtl_skipwhite :-
    xtl_skipwhite("", "").

typed(xtl_white(+bytes, -bytes)).
xtl_white --> "%", !, xtl_line_comment_, xtl_skipwhite.
xtl_white --> (" "; "\t"; "\r" ; "\n" ), !, xtl_skipwhite.

test xtl_white :-
    xtl_white(" ", ""),
    xtl_white("%", ""),
    xtl_white("% comment \n\t  ", "").

xtl_line_comment_ --> ("\n" ; eof), !.
xtl_line_comment_ --> [_], xtl_line_comment_.

typed(xtl_top_level(-list(declaration), +bytes, -bytes)).
xtl_top_level(Decls) -->
    ( "#!", !, xtl_line_comment_; { true }),
    xtl_skipwhite,
    many(xtl_declaration, Decls),
    require(eof).

typed(xtl_declaration(-declaration, +bytes, -bytes)).
xtl_declaration(_) --> eof, !, {fail}.
xtl_declaration(Decl) --> xtl_expression(DeclV), { xtl_makevars(DeclV, Decl, _) }, require(xtl_token(".")).

xtl_makevars(V, _, _) :-
    V =.. ['XTL$VARNAME', '_'], !.
xtl_makevars(V, Var, Vars) :-
    V =.. ['XTL$VARNAME', Name], !,
    member(Name-Var, Vars), !.
xtl_makevars(Atomic, Atomic, _) :-
    atomic(Atomic), !.
xtl_makevars([X|Xs], [Y|Ys], Vars) :- !,
    xtl_makevars(X, Y, Vars),
    xtl_makevars(Xs, Ys, Vars).
xtl_makevars(In, Out, Vars) :-
    In =.. InL, !,
    xtl_makevars(InL, OutL, Vars),
    Out =.. OutL.

test xtl_makevars :-
    A =.. ['XTL$VARNAME', 'A'],
    xtl_makevars(foo(A, A), foo(1, Z), V),
    atomic(Z),
    Z = 1.

typed(xtl_atom_char(-byte, +bytes, -bytes)).
xtl_atom_char(C) -->
    [C], !,
    { member(C, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789?$") }.

typed(xtl_atom(-atom, +bytes, -bytes)).
xtl_atom(Atom) -->
    "'",
    xtl_quoted_atom_chars_(Cs),
    { atom_codes(Atom, Cs) }.
xtl_atom(AtomVar) -->
    many1(xtl_atom_char, Cs), !,
    { atom_codes(Atom, Cs),
      Cs = [C|_],
      ( C = 0'_, !,
        AtomVar =.. ['XTL$VARNAME', '_']
      ; member(C, "ABCDEFGHIJKLMNOPQRSTUVWXYZ"),
        !, AtomVar =.. ['XTL$VARNAME', Atom]
      ; AtomVar = Atom )}.

test xtl_atom :-
    xtl_atom(a, "'a'", ""),
    xtl_atom('+', "'+'", ""),
    xtl_atom('9', "'\\9'", ""),
    xtl_atom(ab, "ab", ""),
    xtl_atom('ab?', "ab?", "").

typed(xtl_quoted_char(-byte, +bytes, -bytes)).
xtl_quoted_char(C) -->
    "\\", !,
    require([Quoted]),
    { member(Quoted : C, [
                 0'n : 10,
                 0'r : 13,
                 0't : 9,
                 0'e : 127,
                 AsIs : AsIs
    ]) }, !.

typed(xtl_quoted_atom_chars_(-list(bytes), +bytes, -bytes)).
xtl_quoted_atom_chars_([]) --> "'", !.
xtl_quoted_atom_chars_([C | Cs]) -->
    xtl_quoted_char(C), !,
    xtl_quoted_atom_chars_(Cs).
xtl_quoted_atom_chars_([C | Cs]) -->
    [C],
    xtl_quoted_atom_chars_(Cs).

typed(xtl_expression(-term, +bytes, -bytes)).
xtl_expression(Expr) -->
    xtl_expression(1201, Expr).

typed(xtl_expression(+precedence, -term, +bytes, -bytes)).
xtl_expression(Prec, Expr) -->
    xtl_expression(none, Prec, Expr).

test xtl_expression :-
    xtl_expression(1, "1", []),
    xtl_expression(a, "a", []),
    xtl_expression(a + b, "a + b", []),
    xtl_expression(a + (b * c), "a + b * c", []),
    xtl_expression((a * b) + c, "a * b + c", []),
    xtl_expression((-a) * b, "-a * b", []),
    xtl_expression((:- (a * b)), ":- a * b", []).

test comma_expr :-
    xtl_expression((p :- (a, b)), "p :- a, b", []).

typed(xtl_regular_term(-term, +bytes, -bytes)).
xtl_regular_term(Char) --> "0'", !, require(xtl_string_char(Char)), xtl_skipwhite.
xtl_regular_term(Integer) -->
    many1(digit, Ds), !,
    { foldl(add_digit, 0, Ds, Integer) },
    xtl_skipwhite.
xtl_regular_term(String) --> "\"", !, require(many(xtl_string_char, String)), require("\""), xtl_skipwhite.
xtl_regular_term(Term) -->
    xtl_atom(Atom), !,
    ( xtl_token("("), !,
      xtl_comma_separated(Args, [], xtl_token(")")),
      { Term =.. [Atom | Args] }
    ; xtl_skipwhite,
      { Term = Atom }).
xtl_regular_term(Term) -->
    xtl_token("("),
    xtl_expression(Term),
    require(xtl_token(")")).
xtl_regular_term('{}'(Term)) -->
    xtl_token("{"),
    xtl_expression(Term),
    require(xtl_token("}")).
xtl_regular_term(Term) -->
    xtl_token("["),
    xtl_comma_separated(Term, Tail,
                       ( xtl_token("]"), {Tail=[]}
                       ; xtl_token("|"), xtl_expression(Tail), xtl_token("]"))), !.

typed(xtl_string_char(-byte, +bytes, -bytes)).
xtl_string_char(_) --> "\"", !, { false }.
xtl_string_char(C) --> xtl_quoted_char(C), !.
xtl_string_char(C) --> [C].

test xtl_regular_term :-
    xtl_regular_term(123, "123", ""),
    xtl_regular_term(hi, "hi", ""),
    xtl_regular_term(hi(1), "hi(1)", ""),
    xtl_regular_term(hi(b, 4), "hi(b, 4)", ""),
    xtl_regular_term(6, "(6)", ""),
    xtl_regular_term('{}'(x), "{x}", ""),
    xtl_regular_term([], "[]", ""),
    xtl_regular_term([1,2,3], "[1,2,3]", "").

typed(xtl_comma_separated(-list(term), +list(term), +sentence, +bytes, -bytes)).
xtl_comma_separated(As, Tail, End) -->
    xtl_comma_seperated_first(As, Tail, End).

xtl_comma_seperated_first(Tail, Tail, End) -->
    dcg_call(End), !.
xtl_comma_seperated_first([A | As], Tail, End) -->
    xtl_expression(1000, A), !,
    xtl_comma_separated_next(As, Tail, End).

xtl_comma_separated_next(Tail, Tail, End) -->
    dcg_call(End), !.
xtl_comma_separated_next([A | As], Tail, End) -->
    require(xtl_token(",")), !,
    xtl_expression(1000, A), !,
    xtl_comma_separated_next(As, Tail, End).

typed(xtl_op_or_term(-term, -op_info, +bytes, -bytes)).
xtl_op_or_term('!', term) --> "!", xtl_skipwhite.
xtl_op_or_term(X, Info) -->
    xtl_regular_term(X), !,
    ( { xtl_op(Prec, Assoc, X), Info = op(Prec, Assoc) }
    ; { Info = term } ).
xtl_op_or_term(X, Info) -->
    many1(xtl_op_char, Cs),
    ( xtl_known_op(Cs, X, Prec, Assoc),
      { Info = op(Prec, Assoc) }
    % ; { atom_codes(X, Cs),
    %     Info = term }
    ),
    xtl_skipwhite.

xtl_known_op(Cs, Op, Prec, Assoc) --> { atom_codes(Op, Cs), xtl_op(_, _, Op), !, xtl_op(Prec, Assoc, Op) }.
xtl_known_op(Cs, Op, Prec, Assoc) --> { append(Shorter, [C], Cs) }, append([C]), xtl_known_op(Shorter, Op, Prec, Assoc).

xtl_op_char(C) -->
    [C], { member(C, "`~!@#%^&*<>/;:-_=+,|\\.") }, !.

typed(xtl_expression(+maybe(term), +precedence, -term, +bytes, -bytes)).
xtl_expression(none, Prec, Term) -->
    xtl_op_or_term(Op, op(OpPrec, Assoc)),
    { member(Assoc-N, [fx-0, fy-1]),
      RightPrec is OpPrec + N },
    try(xtl_expression(none, RightPrec, Right)),
    { Combined =.. [Op, Right] },
    xtl_expression(just(Combined), Prec, Term).
xtl_expression(none, Prec, Term) --> !,
    require(xtl_op_or_term(Left, term)),
    xtl_expression(just(Left), Prec, Term).
xtl_expression(just(Left), Prec, Term) -->
    xtl_op_or_term(Op, op(OpPrec, Assoc)),
    { member(Assoc-N, [xf-0, yf-1]),
      LeftPrec is OpPrec + N,
      LeftPrec < Prec,
      !,
      Combined =.. [Op, Left] },
    xtl_expression(just(Combined), Prec, Term).
xtl_expression(just(Left), Prec, Term) -->
    xtl_op_or_term(Op, op(OpPrec, Assoc)),
    { member(Assoc-N-M, [xfx-0-0, xfy-0-1, yfx-1-0]),
      LeftPrec is OpPrec + N,
      LeftPrec < Prec,
      !,
      RightPrec is OpPrec + M },
    require(xtl_expression(none, RightPrec, Right)),
    { Combined =.. [Op, Left, Right] },
    xtl_expression(just(Combined), Prec, Term).
xtl_expression(just(Term), _, Term) --> !.

typed(xtl_op(-precedence, -associativity, -atom)).
xtl_op(1200, xfx, ':-').
xtl_op(1200, xfx, '-->').
xtl_op(1200, fx, ':-').
xtl_op(1105, xfy, '|').
xtl_op(1100, xfy, ';').
xtl_op(1050, xfy, '->').
xtl_op(1000, xfy, ',').
xtl_op(900, fy, '\\+').
xtl_op(700, xfx, '=').
xtl_op(700, xfx, '\\=').
xtl_op(700, xfx, '=..').
xtl_op(700, xfx, '==').
xtl_op(700, xfx, '\\==').
xtl_op(700, xfx, 'is').
xtl_op(700, xfx, '<').
xtl_op(700, xfx, '>').
xtl_op(700, xfx, '=<').
xtl_op(700, xfx, '>=').
xtl_op(700, xfx, '=\\=').
xtl_op(600, xfy, ':').
xtl_op(500, yfx, '+').
xtl_op(500, yfx, '-').
xtl_op(400, yfx, '*').
xtl_op(400, yfx, '/').
xtl_op(400, yfx, 'rem').
xtl_op(400, yfx, 'mod').
xtl_op(400, yfx, 'div').
xtl_op(400, yfx, '<<').
xtl_op(400, yfx, '>>').
xtl_op(200, xfx, '**').
xtl_op(200, xfx, '^').
xtl_op(200, fy, '+').
xtl_op(200, fy, '-').

xtl_op(1200, fy, test).
xtl_op(999, fx, tc).

test parse_self :-
    read_file('main.xtl', Bytes), !,
    xtl_top_level(_Decls, Bytes, []).

test regression :-
    xtl_declaration(_Decl, ":- discontiguous('/'(test, 1)).", "").

%% Extol to Prolog

xtl_to_pl_toplevel(XTL, PL) :-
    maplist(xtl_to_pl_declaration, XTL, DeclsPL),
    append([
                  (:- set_prolog_flag(singleton_warning, off)),
                  (:- op(1200, fy, test)),
                  (:- op(999, fx, tc))
              ], DeclsPL, PL).

xtl_to_pl_declaration((HeadXTL :- GoalXTL), (HeadPL :- GoalPL)) :- !,
    copy_term(HeadXTL-GoalXTL, HeadPL-Goal),
    xtl_to_pl_goal(Goal, GoalPL),
    numbervars(HeadPL-GoalPL).
xtl_to_pl_declaration((:- Q), (:- Q)) :- !, numbervars(Q).
xtl_to_pl_declaration((test T), (test T)) :- !, numbervars(T).
xtl_to_pl_declaration((N --> L), (NPL :- LPL)) :- !,
     N =.. [F|A],
     append(A, [I, O], AIO),
     NPL =.. [F|AIO],
     xtl_to_pl_dcg(L, LPL, I, O),
     numbervars(NPL-LPL).
xtl_to_pl_declaration(X, X) :- !, numbervars(X).

xtl_to_pl_goal(Var, _) :-
    var(Var), !,
    throw(error(uninstantiated_goal(Var))).
xtl_to_pl_goal((A, B), (APL, BPL)) :- !,
    xtl_to_pl_goal(A, APL),
    xtl_to_pl_goal(B, BPL).
xtl_to_pl_goal((A; B), (APL; BPL)) :- !,
    xtl_to_pl_goal(A, APL),
    xtl_to_pl_goal(B, BPL).
xtl_to_pl_goal('!', '!') :- !.
xtl_to_pl_goal(G, GPL) :-
    G = GPL.

xtl_to_pl_dcg((A, B), (APL, BPL), I, O) :- !,
    xtl_to_pl_dcg(A, APL, I, IO),
    xtl_to_pl_dcg(B, BPL, IO, O).
xtl_to_pl_dcg((A; B), (APL; BPL), I, O) :- !,
    xtl_to_pl_dcg(A, APL, I, O),
    xtl_to_pl_dcg(B, BPL, I, O).
xtl_to_pl_dcg((!), (!, I=O), I, O) :- !.
xtl_to_pl_dcg([], (I=O), I, O) :- !.
xtl_to_pl_dcg([X|XS], append([X|XS], O, I), I, O) :- !.
xtl_to_pl_dcg({G}, (G, I=O), I, O) :- !.
xtl_to_pl_dcg(F, C, I, O) :- !,
    F =.. L,
    append(L, [I,O], LL),
    C =.. LL.
xtl_to_pl_dcg(D,_,_,_) :-
    throw(error(xtl_to_pl_dcg, D)).

test xtl_to_pl_dcg :-
    xtl_to_pl_dcg(((f; g), h), ((f(a, b); g(a, b)), h(b, c)), a, c),
    xtl_to_pl_dcg((e, (f, i; g), h), (e(a, b), (f(b, c), i(c, d); g(b, d)), h(d, e)), a, e).

test xtl_to_pl_dcg_regression :-
    XTL = (
        c_declaration(declare(Name, Type, Value)) -->
            c_type(Type),
            [symbol(Name)],
            ( [operator('=')],
              c_value(Assign),
              !,
              { Value = value(Assign) }
            ; { Value = none } ),
            [operator(';')]),
    xtl_to_pl_declaration(XTL, PL),
    PL = (c_declaration(declare(A,B,C),D,E) :-
              c_type(B,D,F),
              append([symbol(A)],G,F),
              ( append([operator('=')], H, G),
                c_value(I,H,J),
                (!, J = K),
                (C = value(I), K = L)
              ; C = none,
                G = L),
              append([operator(';')], M, L)).

xtl_check_types(Decls) :-
    copy_term(Decls, TypedDecls),
    TypeEnv = tenv(Types, Preds),
    maplist(xtl_gather_types(TypeEnv), Decls),
    length(Types, _),
    length(Preds, _), !,
    maplist(xtl_check_types(TypeEnv), Decls).

xtl_gather_types(tenv(_, Preds), typed(Pred)) :- !,
    Pred =.. [F | A],
    length(A, N),
    member((F/N):T, Preds),
    error_unless(var(T), already_typed(Pred, T)),
    T = Pred.
xtl_gather_types(tenv(Types, _), (type(T) :- Body)) :- !,
    member((T:-Body), Types).
xtl_gather_types(_, _).

test xtl_gather_types :-
    xtl_gather_types(tenv([], []), foo).
    %xtl_gather_types(tenv([], [f/0 : f]), typed(f)),
    %xtl_gather_types(tenv([], [f/1 : f(5)]), typed(f(5))),
    %xtl_gather_types(tenv([(one :- two)], []), (type(one) :- two)).

xtl_check_types(_, (:- _)) :- !.
xtl_check_types(_, type(_)) :- !.
xtl_check_types(_, typed(_)) :- !.
xtl_check_types(_, test((_ :- Tests))) :- !,
    xtl_check_type_goal(Env, Vars, Tests).
xtl_check_types(Env, (Head :- Body)) :- !,
    xtl_check_type_head(Env, Vars, Head),
    xtl_check_type_goal(Env, Vars, Body),
    xtl_check_type_vars(Env, Vars).
xtl_check_types(Env, Head) :-
    xtl_check_type_head(Env, Vars, Head),
    xtl_check_type_vars(Env, Vars).

xtl_check_type_head(Env, Vars, Head) :-
    Head =.. [F | A],
    length(A, N),
    tenv_lookup_predicate(Env, F/N, T),
    maplist(xtl_check_type_assign(Env, Vars), A, T).

xtl_check_type_goal(Env, Vars, A = B) :- !,
    xtl_type_check_assign(Env, Vars, A, B).
xtl_check_type_goal(Env, Vars, Goal) :-
    xtl_type_check_call(Env, Vars, Goal).

xtl_type_check_call(Env, Vars, Goal) :-
    Goal =.. [F | A],
    length(A, N),
    tenv_lookup_predicate(Env, F/N, T),
    maplist(xtl_check_type_expr(Env, Vars), A, T).

xtl_check_type_expr(Env, Vars, Var, Type) :-
    var(Var), !,
    Var = '$type'(Type).
xtl_check_type_expr(Env, Vars, '$type'(GivenType), ExpectedType) :-
    xtl_type_union(Env, GivenType, ExpectedType).
xtl_check_type_expr(Env, Vars, Functor, unique(UniqueTag)) :-
    !, throw(error(functor_is_not_unique(Functor, UniqueTag))).
xtl_check_type_expr(Env, Vars, Functor, constructors(Cases)) :-
    Functor =.. [F | A],
    length(A, N),
    length(T, N),
    error_unless(member([F | T], Cases), no_matching_constructor(Functor, Cases)),
    maplist(xtl_check_type(Env, Vars), A, T).
xtl_check_type_expr(Env, Vars, Expr, UserDefined) :-
    tenv_lookup_type(Env, UserDefined, Type),
    xtl_check_type_expr(Env, Vars, Expr, Type).

tenv_lookup_predicate(tenv(_, Preds), FN, T) :-
    member(FN:TT, Preds),
    copy_term(TT, T).

tenv_lookup_type(tenv(Types, _), UserType, Expanded) :-
    UserType =.. [F | A],
    length(A, N),
    length(V, N),
    Query =.. [F | V],
    member((Query :- Body), Types),
    copy_term(Query-Body, UserType-Expanded).

error_unless(Goal, _) :-
    call(Goal), !.
error_unless(_, Error) :-
    throw(error(Error)).

% TODOS

% xtl_refine_type(Env, Vars, Expr, Type) :-
%    tenv_lookup_type(Env, Type, 

% xtl_check_type_vars
% xtl_type_union
