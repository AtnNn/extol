
%% Parsing

dcg many:
% TODO ATN contract((Predicate, List), (callable(Predicate), list_or_partial_list(List)), list(List)),
%((P, [X | Xs]): call(P, X), '__contract_free_many'(P, Xs), !),
((P, [X | Xs]): call(P, X), many(P, Xs), !),
((_, []): []).

dcg many1:
contract((Predicate, List), (callable(Predicate), list_or_partial_list(List)), list(List)),
((P, [X | Xs]): call(P, X), !, many(P, Xs)).

pred eof:
contract((In, Out), (list_or_partial_list(In), list_or_partial_list(Out)), true),
(([], []): true).

pred peek:
contract((Rest, In, Out), (list_or_partial_list(In), list_or_partial_list(Out), list_or_partial_list(Rest)), true),
((Rest, Rest, Rest) : true).

dcg alpha:
contract((C), true, number(C)),
((C): [C], { member(C, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ") }).

dcg digit:
contract((D), true, number(D)),
((D):
    [C],
    { member(C - D, [0'0 - 0, 0'1 - 1, 0'2 - 2, 0'3 - 3, 0'4 - 4, 0'5 - 5, 0'6 - 6, 0'7 - 7, 0'8 - 8, 0'9 - 9]) }).

prolog dcg_call(Var) --> { var(Var), !, fail }.
prolog dcg_call([]) --> !, [].
prolog dcg_call([X | Xs]) --> !, [X], Xs.
prolog dcg_call((A, B)) --> !, A, B.
prolog dcg_call((A ; _)) --> A.
prolog dcg_call((_ ; B)) --> !, B.
prolog dcg_call({A}) --> !, { A }.
prolog dcg_call(G, I, O) :- !, call(G, I, O).

prolog require(N, Xs, Rest) :-
    ( dcg_call(N, Xs, Rest), !
    ; pretty_init(Xs, C), throw(parse_failed(N, C)) ).

pred must:
((G): undo(throw(failed(G))), G).
pred must:
((G, A): undo(throw(failed(call(G, A)))), call(G, A)).
pred must:
((G, A, B): undo(throw(failed(call(G, A, B)))), call(G, A, B)).
pred must:
((G, A, B, C): undo(throw(failed(call(G, A, B, C)))), call(G, A, B, C)).

prolog try(N, Xs, Rest) :- catch(dcg_call(N, Xs, Rest), parse_failed(_, _), Failed=true), !, Failed=false.